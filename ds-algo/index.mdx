# LinkedList Data Structure

## Introduction
A LinkedList is a linear data structure where elements are stored in nodes, and each node points to the next node in the sequence. Unlike arrays, LinkedList elements are not stored in contiguous memory locations.

## Basic Structure
```java
class Node {
    int data;      // Data stored in the node
    Node next;     // Reference to the next node
}
```

## Types of LinkedList
1. **Singly LinkedList**: Each node has data and a reference to the next node
2. **Doubly LinkedList**: Each node has data and references to both next and previous nodes
3. **Circular LinkedList**: Last node points back to the first node (can be singly or doubly)

## Key Operations and Time Complexity
| Operation | Time Complexity | Description |
|-----------|----------------|-------------|
| Insertion at beginning | O(1) | Add node at head |
| Insertion at end | O(1) with tail pointer | Add node at tail |
| Insertion at position | O(n) | Traverse to position then insert |
| Deletion at beginning | O(1) | Remove head node |
| Deletion at end | O(n) | Traverse to end then remove |
| Search | O(n) | Linear search through nodes |

## Advantages
- Dynamic size
- Easy insertion and deletion
- No memory wastage
- Can grow and shrink during runtime

## Disadvantages
- Extra memory for storing references
- No random access
- Not cache friendly
- Reverse traversing not possible in singly linked list

## Common Interview Questions

### Basic Questions
1. How to implement a singly linked list?
2. How to reverse a linked list?
3. How to find the middle element?
4. How to detect a cycle in a linked list?
5. How to find the nth node from the end?

### Advanced Questions
1. How to merge two sorted linked lists?
2. How to detect and remove a loop?
3. How to check if a linked list is palindrome?
4. How to implement LRU cache using linked list?
5. How to flatten a multilevel linked list?

## Code Patterns to Remember

### 1. Fast and Slow Pointer (Floyd's Algorithm)
```java
Node slow = head;
Node fast = head;
while (fast != null && fast.next != null) {
    slow = slow.next;
    fast = fast.next.next;
}
// slow is at middle
```

### 2. Reversing a LinkedList
```java
Node prev = null;
Node current = head;
Node next = null;
while (current != null) {
    next = current.next;
    current.next = prev;
    prev = current;
    current = next;
}
head = prev;
```

### 3. Finding nth node from end
```java
Node main = head;
Node ref = head;
// Move ref n positions
for(int i = 0; i < n; i++) {
    ref = ref.next;
}
// Move both pointers
while(ref != null) {
    main = main.next;
    ref = ref.next;
}
// main is at nth node from end
```

## Common Edge Cases to Consider
1. Empty list
2. Single node
3. Two nodes
4. Multiple nodes with duplicate values
5. Circular linked list
6. NULL inputs

## Best Practices
1. Always maintain head pointer
2. Consider using tail pointer for O(1) insertions at end
3. Handle edge cases first
4. Use dummy nodes for simplified edge case handling
5. Always check for null before dereferencing

## Memory Management Tips
1. Properly handle node deletion to avoid memory leaks
2. Be careful with circular references
3. Clear all node references when deleting the list
4. Consider using weak references in specific cases

## Interview Tips
1. Always clarify the type of linked list (singly/doubly/circular)
2. Discuss space-time complexity tradeoffs
3. Mention edge cases before coding
4. Consider both iterative and recursive solutions
5. Discuss how to optimize using additional data structures

## Real-world Applications
1. Implementation of undo functionality
2. Music playlist management
3. Browser's forward/backward navigation
4. Memory allocation in operating systems
5. Implementation of hash tables (chaining) 